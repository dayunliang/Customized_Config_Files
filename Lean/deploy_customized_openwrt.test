#!/bin/bash
# ===========================================================================
# Lean OpenWrt 定制文件一键部署脚本【逐行详解版】
#
# 功能：
#   1. 检查当前是否处于 OpenWrt 源码根目录
#   2. 如果不在源码根目录，支持自动 git clone 进入
#   3. 克隆自定义配置文件仓库（REPO_URL），自动部署到指定路径
#   4. 对已存在的目标文件进行备份（加时间戳后缀，防止覆盖丢失）
#   5. 自动检测 luci feed，避免 po2lmo 工具缺失
#   6. 执行 feeds update/install + make defconfig
#   7. 强制编译 po2lmo（解决 default-settings 编译时报错问题）
#   8. 首次构建可选执行 make download 并循环校验下载完整性
#   9. 输出执行摘要和备份清单
# 作者：https://github.com/dayunliang
# ===========================================================================

set -e  # 遇到任何命令出错立即退出（防止错误继续执行）

# ==== [1] 环境检查 ====
if [ -z "$BASH_VERSION" ]; then
    echo "❗ 必须在 bash 环境下执行此脚本，sh 环境不支持！"
    exit 1
fi

# ==== [2] 检查是否在 OpenWrt 源码根目录 ====
# 判定依据：必须同时存在 scripts/feeds 文件和 package 目录

# spinner 函数：显示转动提示符
show_spinner() {
    local pid=$1
    local delay=0.1
    local spinstr='|/-\'
    while ps -p $pid > /dev/null 2>&1; do
        local temp=${spinstr#?}
        printf " [%c] 正在清空目录..." "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\r%-40s\r" " "   # 清空整行避免残留
    done
}

if [ ! -f "./scripts/feeds" ] || [ ! -d "./package" ]; then
    echo "🔍 未检测到 OpenWrt 源码根目录。"
    read -p "是否自动 clone OpenWrt 仓库并进入？(y/N): " confirm
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        read -p "请输入 OpenWrt 仓库 URL (默认: https://github.com/coolsnowwolf/lede.git): " repo_url
        repo_url=${repo_url:-https://github.com/coolsnowwolf/lede.git}

        read -p "请输入目标目录名 (默认: lede): " target_dir
        target_dir=${target_dir:-lede}

        if [ -d "$target_dir" ]; then
            echo "⚠️ 目录 $target_dir 已存在，进入该目录..."
            cd "$target_dir"

            if [ -z "$(ls -A .)" ]; then
                echo "🌐 目录为空，正在克隆 $repo_url ..."
                git clone --depth=1 "$repo_url" . || { echo "❌ 克隆失败"; exit 1; }
            else
                read -p "⚠️ 当前目录非空，是否清空后再克隆？(y/N): " clear_confirm
                if [[ "$clear_confirm" =~ ^[Yy]$ ]]; then
                    (rm -rf ./* ./.??* ) &
                    pid=$!
                    show_spinner $pid
                    wait $pid
                    echo "✅ 目录已清空"
                    echo "🌐 开始克隆 $repo_url ..."
                    git clone --depth=1 "$repo_url" . || { echo "❌ 克隆失败"; exit 1; }
                else
                    if [ ! -f "./scripts/feeds" ] || [ ! -d "./package" ]; then
                        echo "❌ 当前目录不是有效的 OpenWrt 源码目录，无法继续"
                        exit 1
                    fi
                    echo "➡️ 跳过 git clone，继续执行后续步骤..."
                fi
            fi
        else
            echo "🌐 正在克隆 $repo_url 到 $target_dir ..."
            git clone --depth=1 "$repo_url" "$target_dir" || { echo "❌ 克隆失败"; exit 1; }
            cd "$target_dir"
        fi
        echo "✅ 已进入源码目录：$(pwd)"
    else
        echo "❌ 请先手动下载源码再运行本脚本"
        echo "示例："
        echo "  git clone https://github.com/coolsnowwolf/lede.git"
        echo "  cd lede"
        echo "  bash $0"
        exit 1
    fi
fi

# ==== [3] 基本变量 ====
REPO_URL="https://github.com/dayunliang/Customized_Config_Files.git" # 配置文件仓库
TMP_DIR=$(mktemp -d)    # 临时目录（脚本结束会删除）
TS=$(date +%Y%m%d-%H%M%S) # 当前时间戳，用于备份文件命名
declare -a BACKUP_LIST  # 数组，用于记录备份文件路径

# ==== [3] 克隆定制配置文件仓库 ====
echo "1. 克隆定制配置仓库到临时目录 $TMP_DIR ..."
if ! git clone --depth=1 "$REPO_URL" "$TMP_DIR"; then
    echo "❌ 克隆仓库失败：$REPO_URL"
    exit 1
fi

# ==== [4] 编译版本选择逻辑 ====
echo
echo "请选择要部署的编译版本："
echo " 1) Beverly"
echo " 2) Riviera"
echo " 3) DOITCHINA"
read -p "请输入数字 (1-3): " compile_choice

case "$compile_choice" in
  1) COMPILE_NAME="Beverly" ;;
  2) COMPILE_NAME="Riviera" ;;
  3) COMPILE_NAME="DOITCHINA" ;;
  *) echo "❌ 无效选择：$compile_choice"; exit 1 ;;
esac
echo "已选择编译版本：$COMPILE_NAME"
echo

# ==== [5] 定义安全复制函数（带备份） ====
safe_cp() {
    src="$1"  # 源文件
    dst="$2"  # 目标文件
    if [ -f "$dst" ]; then
        backup_name="$dst.bak.$TS"
        cp -v "$dst" "$backup_name"  # 备份旧文件
        BACKUP_LIST+=("$backup_name")
    fi
    cp -vf "$src" "$dst"  # 覆盖复制新文件
}

# ==== [6] 部署文件函数 ====
deploy_file() {
    desc="$1" # 描述（方便日志输出）
    src="$2"  # 源路径
    dst="$3"  # 目标路径
    if [ ! -f "$src" ]; then
        echo "❌ 缺失文件 [$desc]：$src"
        exit 1
    fi
    mkdir -p "$(dirname "$dst")" # 确保目录存在
    safe_cp "$src" "$dst"        # 复制文件
}

# ==== [7] 部署配置文件 ====
echo "2. 部署 [$COMPILE_NAME] 编译版本配置文件..."

# .config 文件（编译选项）
deploy_file ".config" "$TMP_DIR/Lean/config.$COMPILE_NAME" "./.config"

# feeds.conf.default（feeds 源列表）
deploy_file "feeds.conf.default" "$TMP_DIR/Lean/feeds.conf.default.$COMPILE_NAME" "./feeds.conf.default"

# 默认系统设置（包含编译后的默认配置）
deploy_file "zzz-default-settings" "$TMP_DIR/Lean/zzz-default-settings.$COMPILE_NAME" "./package/lean/default-settings/files/zzz-default-settings"

# 回程路由脚本
deploy_file "back-route-checkenv.sh" "$TMP_DIR/Lean/files/usr/bin/back-route-checkenv.sh" "./files/usr/bin/back-route-checkenv.sh"
deploy_file "back-route-complete.sh" "$TMP_DIR/Lean/files/usr/bin/back-route-complete.sh" "./files/usr/bin/back-route-complete.sh"
deploy_file "back-route-cron.sh" "$TMP_DIR/Lean/files/usr/bin/back-route-cron.sh" "./files/usr/bin/back-route-cron.sh"
chmod +x ./files/usr/bin/back-route-*.sh || true

# IPSec 配置
deploy_file "IPSec 配置文件" "$TMP_DIR/Lean/files/etc/ipsec.conf.$COMPILE_NAME" "./files/etc/ipsec.conf"
deploy_file "IPSec 密码文件" "$TMP_DIR/Lean/files/etc/ipsec.secrets.$COMPILE_NAME" "./files/etc/ipsec.secrets"
deploy_file "IPSec Web 配置" "$TMP_DIR/Lean/files/etc/config/luci-app-ipsec-server.$COMPILE_NAME" "./files/etc/config/luci-app-ipsec-server"

# OpenClash 配置和规则
deploy_file "Openclash 配置" "$TMP_DIR/Lean/files/etc/config/openclash.$COMPILE_NAME" "./files/etc/config/openclash"
deploy_file "Openclash 自定义规则" "$TMP_DIR/Lean/files/etc/openclash/custom/openclash_custom_rules.list.$COMPILE_NAME" "./files/etc/openclash/custom/openclash_custom_rules.list"
deploy_file "Openclash 规则列表" "$TMP_DIR/Lean/files/usr/share/openclash/res/rule_providers.list" "./files/usr/share/openclash/res/rule_providers.list"

deploy_file "Openclash DNS false 修改脚本" "$TMP_DIR/Lean/files/etc/openclash/dns_enable_false.sh" "./files/etc/openclash/dns_enable_false.sh"
chmod +x ./files/etc/openclash/dns_enable_false.sh || true
deploy_file "Openclash 节点配置脚本" "$TMP_DIR/Lean/files/usr/share/openclash/yml_proxys_set.sh" "./files/usr/share/openclash/yml_proxys_set.sh"
chmod +x ./files/usr/share/openclash/yml_proxys_set.sh || true

# 其它网络加速、计划任务等配置
deploy_file "ShadowSocksR Plus+ 配置" "$TMP_DIR/Lean/files/etc/config/shadowsocksr" "./files/etc/config/shadowsocksr"
deploy_file "Turbo ACC 网络加速配置" "$TMP_DIR/Lean/files/etc/config/turboacc" "./files/etc/config/turboacc"
deploy_file "root 用户计划任务" "$TMP_DIR/Lean/files/etc/crontabs/root" "./files/etc/crontabs/root"
deploy_file "去除编译循环冲突" "$TMP_DIR/Lean/remove_conflict.sh" "./remove_conflict.sh"
chmod +x ./remove_conflict.sh || true

# ==== [8] 删除临时目录 ====
echo "4. 删除临时目录 $TMP_DIR"
rm -rf "$TMP_DIR"

# ==== [9] 检查 luci feed（po2lmo 工具所在位置） ====
if ! grep -qE '^src-git[[:space:]]+luci[[:space:]]+' feeds.conf.default; then
    echo "⚠️  feeds.conf.default 缺少 luci 源，已自动追加"
    echo "src-git luci https://github.com/coolsnowwolf/luci" >> feeds.conf.default
fi

# 更新 luci feed 并安装 luci-base（包含 po2lmo）
./scripts/feeds update luci
./scripts/feeds install luci-base

# ==== [10] 全量更新安装 feeds 并添加 luci-theme-neobird ====
echo "🛠️ 正在执行 feeds update/install..."
./scripts/feeds clean
./scripts/feeds update -a
./scripts/feeds install -a

echo "🌈 添加 luci-theme-neobird..."
mkdir -p package/lean
rm -rf package/lean/luci-theme-neobird
git clone https://github.com/thinktip/luci-theme-neobird.git package/lean/luci-theme-neobird

./remove_conflict.sh

make defconfig

# ==== [11] 编译 po2lmo 工具 ====
echo "🛠️ 编译 po2lmo 工具..."
make package/feeds/luci/luci-base/host/compile V=s

# ==== [12] 首次构建可选下载源码包 ====
read -p "🧐 是否首次构建？需要预下载源码包？(y/N): " is_first
if [[ "$is_first" =~ ^[Yy]$ ]]; then
    echo "📥 开始预下载源码包..."
    while true; do
        make download -j8 V=s
        broken=$(find dl -size -1024c)
        if [ -z "$broken" ]; then
            echo "✅ 下载完成且校验通过"
            break
        else
            echo "⚠️ 检测到不完整文件，重新下载..."
            find dl -size -1024c -exec rm -f {} \;
        fi
    done
else
    echo "✅ 跳过预下载，可直接 make -j\$(nproc) V=s"
fi

# ==== [13] 显示备份列表 ====
if [ ${#BACKUP_LIST[@]} -gt 0 ]; then
    echo "🗂️ 本次备份的文件："
    for f in "${BACKUP_LIST[@]}"; do echo "  $f"; done
else
    echo "🗂️ 本次没有文件被覆盖，因此没有备份"
fi

# ==== [14] 总结 ====
echo "📋 执行步骤总结："
echo "-------------------------------------------------------"
echo "✅ 部署定制文件"
echo "✅ 自动备份已有配置"
echo "✅ 执行 feeds update/install & make defconfig"
echo "✅ 编译 po2lmo 工具"
echo "✅ （可选）下载源码包并校验"
echo "-------------------------------------------------------"

# ==== [15] 完成提示 ====
echo "🚀 配置部署完成！"
echo "👉 请运行: cd $(pwd) 进入源码目录"
echo "💡 可执行：make -j\$(nproc) V=s"
