#!/bin/bash
# ===========================================================================
# Lean OpenWrt 定制文件一键部署脚本
# 功能：
#   1. 自动检测是否在 OpenWrt 源码根目录运行，否则可选择自动 git clone 并进入
#   2. 克隆自定义配置文件仓库（REPO_URL），并将文件部署到对应路径
#   3. 对已存在的目标文件进行自动备份（加时间戳后缀）
#   4. 自动检测并追加 luci feed（避免 po2lmo 缺失）
#   5. 执行 feeds update/install + make defconfig
#   6. 强制编译 po2lmo 工具（避免 default-settings 编译时报错）
#   7. 可选执行 make download 并循环校验下载完整性
#   8. 最终输出执行摘要和备份清单
# 作者：https://github.com/dayunliang
# ===========================================================================

set -e  # 遇到任何命令返回非0状态，立刻退出，防止错误继续传播

# ==== [0] 环境检查 ====
if [ -z "$BASH_VERSION" ]; then
    echo "❗ 本脚本必须在 bash 环境运行（sh 不行），请用 bash 执行！"
    exit 1
fi

# ==== [1] 确认当前是否在 OpenWrt 源码根目录 ====
# 检查 scripts/feeds 脚本 和 package 目录是否存在
# 如果不存在，就提示用户是否需要自动克隆源码
if [ ! -f "./scripts/feeds" ] || [ ! -d "./package" ]; then
    echo "🔍 未检测到 OpenWrt 源码根目录。"
    cd ~
    echo "📁 已切换到用户主目录: $PWD"
    read -p "是否需要自动 clone OpenWrt 仓库并进入该目录？(y/N): " confirm
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        # 让用户选择 OpenWrt 仓库 URL，默认是 Lean 源
        read -p "请输入 OpenWrt 仓库 URL (默认: https://github.com/coolsnowwolf/lede.git): " repo_url
        repo_url=${repo_url:-https://github.com/coolsnowwolf/lede.git}

        # 让用户选择克隆到的目录名
        read -p "请输入目标目录名 (默认: lede): " target_dir
        target_dir=${target_dir:-lede}

        echo "🌐 正在克隆 $repo_url 到 $target_dir ..."
        git clone --depth=1 "$repo_url" "$target_dir" || {
            echo "❌ 克隆失败，请检查 URL 或网络。"
            exit 1
        }
        cd "$target_dir"
        echo "✅ 已进入目录 $(pwd)，继续执行脚本。"
    else
        # 用户拒绝自动 clone，则退出并给出提示
        script_name=$(basename "$0")
        echo
        echo "请手动 clone 并进入源码目录后再执行脚本："
        echo "  git clone https://github.com/coolsnowwolf/lede.git"
        echo "  cd lede"
        echo "  ./$script_name"
        exit 1
    fi
fi

# ==== [2] 基本变量定义 ====
REPO_URL="https://github.com/dayunliang/Customized_Config_Files.git" # 自定义配置仓库
TMP_DIR=$(mktemp -d)    # 创建临时目录用于克隆配置仓库
TS=$(date +%Y%m%d-%H%M%S) # 时间戳，用于备份文件命名
declare -a BACKUP_LIST  # 用于记录备份的文件路径

# ==== [3] 克隆定制配置仓库 ====
echo "1. 克隆自定义文件仓库到临时目录 $TMP_DIR ..."
if ! git clone --depth=1 "$REPO_URL" "$TMP_DIR"; then
    echo "❌ 克隆仓库失败：$REPO_URL"
    exit 1
fi

# ==== [4] 文件复制函数（带自动备份机制） ====
safe_cp() {
    src="$1"  # 源文件路径
    dst="$2"  # 目标文件路径
    if [ -f "$dst" ]; then
        backup_name="$dst.bak.$TS"   # 生成备份文件名
        cp -v "$dst" "$backup_name"  # 备份原文件
        BACKUP_LIST+=("$backup_name") # 记录备份路径
    fi
    cp -vf "$src" "$dst" # 覆盖复制新文件
}

# ==== [5] 部署文件函数（带缺失检测） ====
deploy_file() {
    desc="$1" # 文件描述
    src="$2"  # 源路径
    dst="$3"  # 目标路径
    if [ ! -f "$src" ]; then
        echo "❌ 缺失文件 [$desc]：$src"
        exit 1
    fi
    mkdir -p "$(dirname "$dst")" # 确保目标目录存在
    safe_cp "$src" "$dst"        # 调用 safe_cp 复制
}

# ==== [6] 部署定制配置文件 ====
echo "2. 分发自定义配置文件..."
# 以下所有 deploy_file 调用，依次将 TMP_DIR 中的文件复制到 OpenWrt 对应路径

deploy_file ".config" "$TMP_DIR/Lean/config" "./.config"
echo "📦 .config 已部署"

deploy_file "feeds.conf.default" "$TMP_DIR/Lean/feeds.conf.default" "./feeds.conf.default"
deploy_file "zzz-default-settings" "$TMP_DIR/Lean/zzz-default-settings" "./package/lean/default-settings/files/zzz-default-settings"

deploy_file "back-route-checkenv.sh" "$TMP_DIR/Lean/files/usr/bin/back-route-checkenv.sh" "./files/usr/bin/back-route-checkenv.sh"
deploy_file "back-route-complete.sh" "$TMP_DIR/Lean/files/usr/bin/back-route-complete.sh" "./files/usr/bin/back-route-complete.sh"
deploy_file "back-route-cron.sh" "$TMP_DIR/Lean/files/usr/bin/back-route-cron.sh" "./files/usr/bin/back-route-cron.sh"
chmod +x ./files/usr/bin/back-route-*.sh || true # 给脚本加执行权限

deploy_file "IPSec 配置文件" "$TMP_DIR/Lean/files/etc/ipsec.conf" "./files/etc/ipsec.conf"
deploy_file "IPSec 密码文件" "$TMP_DIR/Lean/files/etc/ipsec.secrets" "./files/etc/ipsec.secrets"
deploy_file "IPSec WEB 配置" "$TMP_DIR/Lean/files/etc/config/luci-app-ipsec-server" "./files/etc/config/luci-app-ipsec-server"

deploy_file "Openclash 自定义规则" "$TMP_DIR/Lean/files/etc/config/openclash" "./files/etc/config/openclash"
deploy_file "Openclash 规则附加" "$TMP_DIR/Lean/files/etc/openclash/custom/openclash_custom_rules.list" "./files/etc/openclash/custom/openclash_custom_rules.list"
deploy_file "Openclash 第三方规则集" "$TMP_DIR/Lean/files/usr/share/openclash/res/rule_providers.list" "./files/usr/share/openclash/res/rule_providers.list"

deploy_file "Openclash DNS false 修改脚本" "$TMP_DIR/Lean/files/etc/openclash/dns_enable_false.sh" "./files/etc/openclash/dns_enable_false.sh"
chmod +x ./files/etc/openclash/dns_enable_false.sh || true
deploy_file "Openclash 服务器节点配置" "$TMP_DIR/Lean/files/usr/share/openclash/yml_proxys_set.sh" "./files/usr/share/openclash/yml_proxys_set.sh"
chmod +x ./files/usr/share/openclash/yml_proxys_set.sh || true

deploy_file "ShadowSocksR Plus+ 配置文件" "$TMP_DIR/Lean/files/etc/config/shadowsocksr" "./files/etc/config/shadowsocksr"
deploy_file "Turbo ACC 网络加速设置" "$TMP_DIR/Lean/files/etc/config/turboacc" "./files/etc/config/turboacc"
deploy_file "root 计划任务" "$TMP_DIR/Lean/files/etc/crontabs/root" "./files/etc/crontabs/root"

# ==== [7] 清理临时目录 ====
echo "4. 清理临时目录 $TMP_DIR"
rm -rf "$TMP_DIR"

# ==== [8] 自动检查 luci feed（防止 po2lmo 缺失） ====
if ! grep -qE '^src-git[[:space:]]+luci[[:space:]]+' feeds.conf.default; then
    echo "⚠️  feeds.conf.default 未检测到 luci 源，自动追加..."
    echo "src-git luci https://github.com/coolsnowwolf/luci" >> feeds.conf.default
else
    echo "✅ 检测到 luci 源，无需追加"
fi

# 仅更新 luci feed，安装 luci-base（po2lmo 在这里）
./scripts/feeds update luci
./scripts/feeds install luci-base

# ==== [9] 全量 feeds 更新和安装 + defconfig ====
echo "🛠️ 构建前准备：feeds update/install + make defconfig"
./scripts/feeds update -a
./scripts/feeds install -a
make defconfig

# ==== [10] 强制编译 po2lmo（避免 default-settings 编译时报错） ====
echo "🛠️ 正在编译 po2lmo 工具..."
if ! make package/feeds/luci/luci-base/host/compile V=s; then
    echo "❌ po2lmo 编译失败，请检查 golang 版本或 feeds 依赖"
    exit 1
fi

# ==== [11] 可选源码预下载 ====
read -p "🧐 是否首次构建？需要预下载源码包？(y/N): " is_first
if [[ "$is_first" =~ ^[Yy]$ ]]; then
    echo "📥 正在预下载源码包..."
    while true; do
        make download -j8 V=s
        broken=$(find dl -size -1024c) # 检查是否有下载不完整的文件
        if [ -z "$broken" ]; then
            echo "✅ 源码包下载完整"
            break
        else
            echo "⚠️ 检测到不完整文件，重新下载"
            echo "$broken"
            find dl -size -1024c -exec rm -f {} \;
        fi
    done
else
    echo "✅ 跳过预下载，建议执行：make -j\$(nproc) V=s"
fi

# ==== [12] 输出备份清单 ====
if [ ${#BACKUP_LIST[@]} -gt 0 ]; then
    echo "🗂️ 本次自动备份文件："
    for f in "${BACKUP_LIST[@]}"; do echo "  $f"; done
else
    echo "🗂️ 无需备份：未检测到同名文件"
fi

# ==== [13] 执行步骤总结 ====
echo "📋 本次执行关键步骤："
echo "-------------------------------------------------------"
echo "✅ 部署定制文件"
echo "✅ 自动备份已有配置"
echo "✅ 下载 OpenClash Provider 规则"
echo "✅ 执行 feeds update/install & make defconfig"
echo "✅ （可选）预下载源码包并校验"
echo "-------------------------------------------------------"

# ==== [14] 最终提示 ====
echo "🚀 所有配置部署和构建准备完成！"
echo "📂 当前目录：$(pwd)"
echo "📝 建议：make -j\$(nproc) V=s"
